# -*- coding: utf-8 -*-
"""ROC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZZOx-jjAXmfUyMZqulJxnSw14kG5Is_2
"""

import os
from transformers import ViTForImageClassification, SwinForImageClassification, ViTFeatureExtractor
import torch
from PIL import Image
import torch.nn.functional as F
from sklearn.metrics import roc_curve, roc_auc_score
import matplotlib.pyplot as plt
import numpy as np
from safetensors.torch import load_file

model_vit = ViTForImageClassification.from_pretrained('/content/drive/MyDrive/Modelo_ViT_Deteccion_Enf_Banano', num_labels=3)
model_vit.load_state_dict(torch.load('/content/drive/MyDrive/Modelo_ViT_Deteccion_Enf_Banano/pytorch_model.bin'))
model_vit.eval()

model_swin = SwinForImageClassification.from_pretrained('/content/drive/MyDrive/Swin', num_labels=3)
model_swin.load_state_dict(load_file('/content/drive/MyDrive/Swin/model.safetensors'))
model_swin.eval()

model_deit = ViTForImageClassification.from_pretrained('/content/drive/MyDrive/Deit', num_labels=3)
model_deit.load_state_dict(load_file('/content/drive/MyDrive/Deit/model.safetensors'))
model_deit.eval()

extractor_vit = ViTFeatureExtractor.from_pretrained('/content/drive/MyDrive/Modelo_ViT_Deteccion_Enf_Banano')
extractor_deit = ViTFeatureExtractor.from_pretrained('/content/drive/MyDrive/Deit')
extractor_swin = ViTFeatureExtractor.from_pretrained('/content/drive/MyDrive/Swin')

def obtener_probabilidades(modelo, extractor, imagen):
    inputs = extractor(images=imagen, return_tensors="pt")
    with torch.no_grad():
        outputs = modelo(**inputs)
        probabilidades = F.softmax(outputs.logits, dim=-1)
    return probabilidades.cpu().numpy()

test_images_folder = '/content/drive/MyDrive/dataset_final/test'

clases = ['BLACK_SIGATOKA', 'HEALTHY', 'MAL_DE_PANAMA']
imagenes = []
y_test = []

for nombre_clase in clases:
    ruta_clase = os.path.join(test_images_folder, nombre_clase)
    for img_name in os.listdir(ruta_clase):
        if img_name.endswith(('.png', '.jpg', '.jpeg')):
            imagenes.append(os.path.join(ruta_clase, img_name))
            y_test.append(clases.index(nombre_clase))

y_test = np.array(y_test)

probabilidades_vit = []
probabilidades_deit = []
probabilidades_swin = []

for img_path in imagenes:
    image = Image.open(img_path).convert('RGB')

    prob_vit = obtener_probabilidades(model_vit, extractor_vit, image)
    prob_deit = obtener_probabilidades(model_deit, extractor_deit, image)
    prob_swin = obtener_probabilidades(model_swin, extractor_swin, image)

    probabilidades_vit.append(prob_vit)
    probabilidades_deit.append(prob_deit)
    probabilidades_swin.append(prob_swin)

probabilidades_vit = np.vstack(probabilidades_vit)
probabilidades_deit = np.vstack(probabilidades_deit)
probabilidades_swin = np.vstack(probabilidades_swin)

import matplotlib.pyplot as plt
from transformers import ViTForImageClassification, ViTFeatureExtractor, SwinForImageClassification
from datasets import load_dataset, Dataset
import torch
from sklearn.metrics import precision_score
import os
from PIL import Image

def load_dataset_from_folder(folder_path):
    images = []
    labels = []
    label_to_id = {"BLACK_SIGATOKA": 0, "HEALTHY": 1, "MAL_DE_PANAMA": 2}

    for label in os.listdir(folder_path):
        label_path = os.path.join(folder_path, label)
        if os.path.isdir(label_path):
            for image_name in os.listdir(label_path):
                image_path = os.path.join(label_path, image_name)
                image = Image.open(image_path).convert("RGB")
                images.append(image)
                labels.append(label_to_id[label])

    return Dataset.from_dict({"image": images, "labels": labels})

def evaluate_model():
    model_path = "/content/drive/MyDrive/Swin/checkpoint-13140"
    model = SwinForImageClassification.from_pretrained(model_path)
    feature_extractor = ViTFeatureExtractor.from_pretrained(model_path)

    test_dataset = load_dataset_from_folder("/content/drive/MyDrive/dataset_final/test")

    def transform(example_batch):
        rgb_images = [img.convert("RGB") for img in example_batch['image']]
        inputs = feature_extractor(rgb_images, return_tensors='pt')
        inputs['labels'] = torch.tensor(example_batch['labels'])
        return inputs

    prepared_test_dataset = test_dataset.with_transform(transform)

    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device)

    model.eval()
    all_preds = []
    all_labels = []

    with torch.no_grad():
        for batch in prepared_test_dataset:
            if len(batch['pixel_values'].shape) == 3:
                batch['pixel_values'] = batch['pixel_values'].unsqueeze(0)

            inputs = {
                'pixel_values': batch['pixel_values'].to(device),
                'labels': batch['labels'].to(device)
            }

            outputs = model(**inputs)
            predictions = outputs.logits.argmax(-1)

            predictions = predictions.view(-1)
            labels = inputs['labels'].view(-1)

            all_preds.extend(predictions.cpu().numpy())
            all_labels.extend(labels.cpu().numpy())

    precision_per_class = precision_score(all_labels, all_preds, average=None)
    average_precision = precision_score(all_labels, all_preds, average='weighted')

    label_names = ["BLACK_SIGATOKA", "HEALTHY", "MAL_DE_PANAMA"]

    precision_dict = {name: float(score) for name, score in zip(label_names, precision_per_class)}
    precision_dict['average'] = float(average_precision)

    return precision_dict

def plot_precision(precisions):
    classes = list(precisions.keys())
    precision_values = list(precisions.values())

    plt.figure(figsize=(8, 6))
    plt.bar(classes, precision_values, color='skyblue')
    plt.xlabel('Clases')
    plt.ylabel('Precisión')
    plt.title('Precisión por clase')

    avg_precision = precisions['average']
    plt.axhline(y=avg_precision, color='r', linestyle='--', label=f'Precisión Promedio ({avg_precision:.4f})')
    plt.legend()

    plt.show()

if __name__ == "__main__":
    precisions = evaluate_model()
    for class_name, precision in precisions.items():
        if class_name == 'average':
            print(f"Precisión Promedio: {precision:.4f}")
        else:
            print(f"Precisión para {class_name}: {precision:.4f}")

    plot_precision(precisions)